---
description: Update existing conceptual documentation to reflect current state
argument-hint: <doc-file>
allowed-tools: Read, Glob, Grep, Write, AskUserQuestion
---

# /doc-refresh — Refresh Conceptual Documentation

Update an existing documentation file to reflect the current state of the code it documents.

## Arguments

**`$ARGUMENTS`**: Path to the documentation file to refresh

- **Doc file path** (required) - The markdown file to update (e.g., `docs/api-architecture.md`, `src/api/README.md`)

Examples:
```
/doc-refresh docs/api-architecture.md
/doc-refresh src/parser/README.md
```

## The Stability Test

Before including ANY detail, ask: **Would this need updating if someone added a new [file/role/config/type/endpoint]?**

- If YES → Don't include it. Stay conceptual, or if specifics are truly needed, link to source rather than inlining.
- If NO → It's likely a stable concept worth documenting.

**Concepts are stable. Implementations change daily.**

A section listing "Available IAM Roles" will break when someone adds a role. A section explaining "How IAM policies are structured and why" remains valid regardless of which specific roles exist.

## What This Command Does

Re-reads the source code that a documentation file describes, then updates the documentation to reflect the current state.

**Key principles:**
- **Snapshot, not changelog**: Write as if documenting fresh, never say "changed from X to Y"
- **No recency bias**: Don't overweight recent changes over the overall system
- **Improve violations**: If the original doc has sections that violate stability principles, propose fixes (with user consent)
- **Preserve what works**: Keep structure/style for sections that ARE conceptual and stable

## Phase 1: Read Existing Documentation

Read the documentation file specified in `$ARGUMENTS`.

## Phase 2: Parse Metadata

Look for the "Generation Metadata" section at the end of the document.

**Expected format:**
```markdown
## Generation Metadata

**Generated by:** `/doc` command
**Date:** YYYY-MM-DD
**Last refreshed:** YYYY-MM-DD (via `/doc-refresh`)  [May not be present on first refresh]
**Source paths:**
- path/to/file1
- path/to/folder/

**Additional context:** [Context from original generation]
```

Extract:
- **Source paths** - What files/folders to re-examine
- **Additional context** - Any clarifying info from original generation

**If metadata is missing or malformed:**
- Read through the document content carefully
- Infer what files/folders it's documenting from:
  - File paths mentioned in the text
  - Component/module names referenced
  - Code snippets or examples shown
- Continue with those inferred paths

## Phase 3: Re-explore Source Code

Read the current state of all source paths:
- For **folders**: Use Glob to find files, Grep to understand structure, Read key files
- For **files**: Read the file(s) and related context

Understand:
- What has stayed the same since the doc was written
- What has evolved or changed
- New components or concepts that emerged
- Deprecated or removed elements

## Phase 3.5: Violation Detection

Analyze the existing document for sections that violate stability principles.

**The key test: Is this list derived from code?**

Code-derived lists are violations because they naturally grow as the codebase evolves. These include:
- Lists of all [policies/types/classes/functions/enums/files/parameters/options]
- Sections like "Available X", "Supported Y", "Configuration", "Policy Files"
- Any enumeration where adding code would require updating the doc

Conceptual lists are fine because they explain stable ideas:
- "Three principles of this design"
- "The data flows through these stages"
- Lists that explain HOW something works, not catalog WHAT exists

**For each section with a list, ask:**
1. Is this list derived from code? (e.g., listing all policies that exist in the codebase)
2. Would this list grow when someone adds new code?
3. Or is this a conceptual list that explains how the system works?

If it's code-derived → violation.
If it's conceptual → fine.

**If violations are found:**
You MUST use `AskUserQuestion` to get explicit user consent before proceeding. List each violation with a proposed fix.

**Template:**
```
I found sections in the existing doc that violate stability principles:

1. **"Available Policy Types"** (lines 45-67) - Code-derived list of all IAM roles
   → Proposed fix: Rewrite as "Policy Architecture" explaining the policy-per-role pattern

2. **"Configuration"** (lines 70-95) - Code-derived list of all config options
   → Proposed fix: Rewrite as "Configuration Model" explaining the structure conceptually

3. **"Policy Files"** (lines 100-130) - Code-derived list of all policy files with descriptions
   → Proposed fix: Remove or replace with conceptual explanation of policy organization

Should I proceed with these improvements?
```

**If no violations:** Proceed directly to Phase 4.

## Phase 4: Update Documentation

Rewrite the documentation to reflect the current state.

### Plan Review (Internal Critique)

Before writing, switch to **Critical Reviewer** persona and evaluate your plan for updating the documentation.

For each section you're about to write or update, ask:
1. **Stability test**: Would this section need updating if someone added a new file/role/config/type?
2. **Concept vs. catalog**: Am I explaining *how something works* or *listing what exists*?
3. **Maintenance burden**: Will this section become stale with routine code changes?

**Review checklist:**
- [ ] No sections that enumerate "all X" (all roles, all files, all configs)
- [ ] No headers like "Available Types", "Configuration Parameters", "Supported Options"
- [ ] Every section passes the stability test
- [ ] If specifics are needed, they link to source rather than being inlined (but links are optional - prefer staying conceptual)

**If a section fails review:** Rewrite the plan at a higher conceptual level. Do NOT proceed to writing until all sections pass.

**Resume writing** only after all sections pass review.

### Critical Guidelines

**Audience:**
Remember you're writing for someone who has just joined the project and is trying to orient themselves. Help them build the right mental model of how this works.

**✓ DO:**
- Describe the system as it is today
- Maintain the same conceptual level and focus as the original
- Preserve the document structure if it serves the reader well, but reorganize if needed for clarity
- Preserve the writing style and tone
- Update any outdated information or examples
- Don't inline code/lists that will become stale (if specifics are needed, link to source rather than inlining - but prefer staying conceptual)
- Use examples to illustrate, not to enumerate exhaustively
- Verify existing links are still valid and update paths if needed

**✗ DO NOT:**
- Use changelog language ("This used to be X, now it's Y")
- Say "previously" or "originally" or "was changed to"
- Overweight recent changes (avoid recency bias)
- Turn the doc into a timeline or history
- Add implementation details if the original was high-level
- Change the focus or purpose of the documentation
- Add directory structure sections
- Inline exhaustive code lists (link to source instead)
- Turn the doc into a code reference
- Create or expand sections that enumerate current instances (all roles, all files, all configs)
- Add detail that would need updating when someone adds new code
- Turn conceptual sections into reference material

### Example Comparisons

**Bad (changelog mentality):**
> The authentication system was originally based on sessions, but has been changed to use JWT tokens. Previously, we stored user data in the session, but now we encode it in the token payload.

**Good (snapshot mentality):**
> The authentication system uses JWT tokens. User identification data is encoded in the token payload, allowing stateless authentication across services.

---

**Bad (recency bias):**
> The system has four main components. The newest addition is the caching layer, which was recently added to improve performance...

**Good (balanced current state):**
> The system has four main components: the request handler, data processor, caching layer, and response formatter. The caching layer improves performance by...

### Code Duplication Guidelines

When refreshing documentation, apply these principles to avoid maintenance burden:

**Don't inline code/lists that will become stale:**
- If the doc lists all values of an enum: replace with conceptual explanation, optionally with 2-4 examples (link to source only if specifics add value)
- If the doc shows full class definitions: replace with conceptual explanation
- If the doc includes directory structure: remove entirely, or replace with specific path mentions
- Any exhaustive list that will change over time should be removed or converted to conceptual explanation

**Acceptable to include when:**
- Explaining a concept that requires seeing the structure (but add disclaimer that it may evolve)
- Showing a stable interface/contract that's central to understanding
- The code snippet is unlikely to change frequently and helps illustrate a key concept
- Remember: links are optional - truly conceptual docs may not need them at all

**Examples:**

Bad (exhaustive list):
> Entity types: PHONE_NUMBER, EMAIL, URL, DOMAIN, IP_ADDRESS, CRYPTO_ADDRESS, CRYPTO_PAYMENT_URI, LIGHTNING_INVOICE, PAYMENT_HANDLE, BANK_COORDINATE_IBAN, BANK_COORDINATE_SWIFT...

Good (examples + link):
> The system recognizes 22 entity types including PHONE_NUMBER, EMAIL, URL, and CRYPTO_ADDRESS. See [`src/models/entities.py`](../src/models/entities.py) for the complete list.

## Phase 4.5: Final Review (Document Quality)

Before saving, switch to **Document Reviewer** persona. Review the complete document holistically for usefulness and organization:

**Usefulness check:**
- Is this document useful for the intended audience?
- Does each section add conceptual value? If a section isn't pulling its weight, either omit it or move it to an appendix if it's borderline/feels out of place.

**Organization check:**
- Does information flow logically? Each section should build on concepts established in earlier sections.
- Is any section confusing until you've read a later section? That's a sign of poor organization - reorder so foundational concepts come first.
- Would a reader need to jump around to understand the document, or can they read top-to-bottom?

**If the document fails these checks:** Reorganize, trim, or add an appendix as needed before saving.

## Phase 5: Update Metadata & Save

Update the metadata section:

```markdown
## Generation Metadata

**Generated by:** `/doc` command
**Date:** [Original date, preserved]
**Last refreshed:** [Today's date] (via `/doc-refresh`)
**Source paths:**
- [Same paths as before, or corrected if wrong]

**Additional context:** [Original context, preserved]
```

Overwrite the original documentation file with the updated content.

Confirm to the user:
```
Documentation refreshed: `[path/to/doc.md]`
```

## Phase 6: Summary

Provide a brief 2-3 sentence summary of what was updated, without going into detailed changes. Focus on scope, not specifics.

**Example:**
```
Refreshed the API architecture documentation. The core conceptual model remains the same, with updates to reflect the current module structure and component relationships.
```

## Important Notes

- **Preserve original intent**: The goal is to keep the doc current, not to rewrite it
- **Maintain quality**: If the original doc was high-quality conceptual writing, match that level
- **Avoid over-updating**: If nothing significant changed, minimal updates are appropriate
- **No recency bias**: Recent changes aren't inherently more important than older stable code

## Examples

### Example 1: Refresh API documentation
```
/doc-refresh docs/api-architecture.md
```
Re-reads the API source code, updates the documentation to reflect current state.

### Example 2: Refresh module README
```
/doc-refresh src/parser/README.md
```
Updates the parser module documentation based on current implementation.
